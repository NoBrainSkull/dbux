defmodule DBux.PeerConnectionSpec do
  use ESpec

  defmodule TestModule do
  end


  describe ".handle_info/2" do
    let :message_queue, do: %{666 => {:something, 1234}}
    let :hello_serial,  do: nil
    let :state,         do: %{buffer: buffer, mod: TestModule, mod_state: %{}, message_queue: message_queue, hello_serial: hello_serial, unwrap_values: true}

    context "if passed message is {:dbux_transport_receive, bitstring}" do
      let :message, do: {:dbux_transport_receive, bitstring}

      context "if buffer is empty" do
        let :buffer, do: << >>

        context "if if bitstring contains a single message" do
          context "if message is a method call" do
            # Hello
            let :bitstring, do: << 0x6c, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00>>

            before do
              allow(TestModule).to accept(:handle_method_call, fn(_, _, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_method_call of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_method_call, [1, nil, "/org/freedesktop/DBus", "Hello", "org.freedesktop.DBus", [], 0, %{}], [pid: self(), count: 1])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a signal" do
            # NameOwnerChanged
            let :bitstring, do: << 0x6c, 0x04, 0x01, 0x01, 0x1d, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4e, 0x61, 0x6d, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x03, 0x73, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 >>

            before do
              allow(TestModule).to accept(:handle_signal, fn(_, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_signal of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_signal, [29, "org.freedesktop.DBus", "/org/freedesktop/DBus", "NameOwnerChanged", "org.freedesktop.DBus", [":1.1624", ":1.1624", ""], %{}], [pid: self(), count: 1])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a method return" do
            # Return to ListNames
            let :bitstring, do: << 0x6c, 0x02, 0x01, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x05, 0x01, 0x75, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x02, 0x61, 0x73, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x33, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x6b, 0x69, 0x74, 0x2e, 0x70, 0x6c, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x33, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x34, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x39, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x36, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x32, 0x00 >>

            before do
              allow(TestModule).to accept(:handle_method_return, fn(_, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            context "and message with such serial was not present in the message queue" do
              let :message_queue, do: %{}

              it "should call handle_method_return of the module with queue id set to nil" do
                described_module.handle_info(message, state)
                expect(TestModule).to accepted(:handle_method_return, [3, "org.freedesktop.DBus", 2, [["org.freedesktop.DBus", ":1.3",
                    "org.radiokit.plumber.backend", ":1.53", ":1.4", ":1.0", ":1.10", ":1.9",
                    ":1.5", ":1.105", ":1.6", ":1.2"]], nil, %{}], [pid: self(), count: 1])
              end

              it "should return a new state with unmodified message queue" do
                {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
                expect(new_message_queue).to eq message_queue
              end
            end

            context "and message with such serial was present in the message queue" do
              let :message_queue, do: %{2 => {:some_queue_id, 1234}, 3 => {:some_other_id, 4567}}

              it "should call handle_method_return of the module with queue id set to appropriate queue id" do
                described_module.handle_info(message, state)
                expect(TestModule).to accepted(:handle_method_return, [3, "org.freedesktop.DBus", 2, [["org.freedesktop.DBus", ":1.3",
                    "org.radiokit.plumber.backend", ":1.53", ":1.4", ":1.0", ":1.10", ":1.9",
                    ":1.5", ":1.105", ":1.6", ":1.2"]], :some_queue_id, %{}], [pid: self(), count: 1])
              end

              it "should return a new state with message queue that does not contain queue id for received message" do
                {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
                expect(new_message_queue).to eq %{3 => {:some_other_id, 4567}}
              end
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          pending "if message is a error"
        end

        context "if if bitstring contains more than one message" do
          let :count, do: 3

          context "if message is a method call" do
            # Hello
            let :bitstring, do: String.duplicate(<< 0x6c, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00>>, 3)

            before do
              allow(TestModule).to accept(:handle_method_call, fn(_, _, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_method_call of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_method_call, [1, nil, "/org/freedesktop/DBus", "Hello", "org.freedesktop.DBus", [], 0, %{}], [pid: self(), count: count])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a signal" do
            # NameOwnerChanged
            let :bitstring, do: String.duplicate(<< 0x6c, 0x04, 0x01, 0x01, 0x1d, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4e, 0x61, 0x6d, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x03, 0x73, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 >>, count)

            before do
              allow(TestModule).to accept(:handle_signal, fn(_, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_signal of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_signal, [29, "org.freedesktop.DBus", "/org/freedesktop/DBus", "NameOwnerChanged", "org.freedesktop.DBus", [":1.1624", ":1.1624", ""], %{}], [pid: self(), count: count])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a method return" do
            # Return to ListNames
            let :bitstring, do: String.duplicate(<< 0x6c, 0x02, 0x01, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x05, 0x01, 0x75, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x02, 0x61, 0x73, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x33, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x6b, 0x69, 0x74, 0x2e, 0x70, 0x6c, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x33, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x34, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x39, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x36, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x32, 0x00 >>, count)

            before do
              allow(TestModule).to accept(:handle_method_return, fn(_, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            context "and message with such serial was not present in the message queue" do
              let :message_queue, do: %{}

              it "should call handle_method_return of the module with queue id set to nil" do
                described_module.handle_info(message, state)
                expect(TestModule).to accepted(:handle_method_return, [3, "org.freedesktop.DBus", 2, [["org.freedesktop.DBus", ":1.3",
                    "org.radiokit.plumber.backend", ":1.53", ":1.4", ":1.0", ":1.10", ":1.9",
                    ":1.5", ":1.105", ":1.6", ":1.2"]], nil, %{}], [pid: self(), count: count])
              end

              it "should return a new state with unmodified message queue" do
                {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
                expect(new_message_queue).to eq message_queue
              end
            end

            # There's no point in testing case when serial was present in the
            # message queue as it will be removed after first call

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          pending "if message is a error"
        end

        context "if bitstring contains a message with missing data" do
          # Hello with missing 1 byte at the end of header padding
          let :bitstring, do: << 0x6c, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00 >>

          before do
            allow(TestModule).to accept(:handle_method_call, fn(_, _, _, _, _, _, _, _) -> {:noreply, %{}} end)
          end

          it "should not call handle_method_call of the module" do
            described_module.handle_info(message, state)
            expect(TestModule).not_to accepted(:handle_method_call)
          end

          it "should return a {:noreply, new_state}" do
            {retval, _new_state} = described_module.handle_info(message, state)
            expect(retval).to eq :noreply
          end

          it "should return a new state with buffer containing received data" do
            {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
            expect(buffer).to eq bitstring
          end

          it "should return a new state with unmodified message queue" do
            {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
            expect(new_message_queue).to eq message_queue
          end

          it "should return a new state with unmodified hello serial" do
            {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
            expect(new_hello_serial).to eq hello_serial
          end
        end
      end

      context "if buffer not empty" do
        let :buffer, do: << 0x6c >>

        context "if if bitstring contains a remaining part of a single message" do
          context "if message is a method call" do
            # Hello with first byte stripped
            let :bitstring, do: << 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00>>

            before do
              allow(TestModule).to accept(:handle_method_call, fn(_, _, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_method_call of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_method_call, [1, nil, "/org/freedesktop/DBus", "Hello", "org.freedesktop.DBus", [], 0, %{}], [pid: self(), count: 1])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a signal" do
            # NameOwnerChanged with first byte stripped
            let :bitstring, do: << 0x04, 0x01, 0x01, 0x1d, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4e, 0x61, 0x6d, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x03, 0x73, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x36, 0x32, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 >>

            before do
              allow(TestModule).to accept(:handle_signal, fn(_, _, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            it "should call handle_signal of the module" do
              described_module.handle_info(message, state)
              expect(TestModule).to accepted(:handle_signal, [29, "org.freedesktop.DBus", "/org/freedesktop/DBus", "NameOwnerChanged", "org.freedesktop.DBus", [":1.1624", ":1.1624", ""], %{}], [pid: self(), count: 1])
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified message queue" do
              {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
              expect(new_message_queue).to eq message_queue
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          context "if message is a method return" do
            # Return to ListNames with first byte stripped
            let :bitstring, do: << 0x02, 0x01, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x05, 0x01, 0x75, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x02, 0x61, 0x73, 0x00, 0x07, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x33, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x6b, 0x69, 0x74, 0x2e, 0x70, 0x6c, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x33, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x34, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x39, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x35, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x31, 0x30, 0x35, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x36, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3a, 0x31, 0x2e, 0x32, 0x00 >>

            before do
              allow(TestModule).to accept(:handle_method_return, fn(_, _, _, _, _, _) -> {:noreply, %{}} end)
            end

            context "and message with such serial was not present in the message queue" do
              let :message_queue, do: %{}

              it "should call handle_method_return of the module with queue id set to nil" do
                described_module.handle_info(message, state)
                expect(TestModule).to accepted(:handle_method_return, [3, "org.freedesktop.DBus", 2, [["org.freedesktop.DBus", ":1.3",
                    "org.radiokit.plumber.backend", ":1.53", ":1.4", ":1.0", ":1.10", ":1.9",
                    ":1.5", ":1.105", ":1.6", ":1.2"]], nil, %{}], [pid: self(), count: 1])
              end

              it "should return a new state with unmodified message queue" do
                {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
                expect(new_message_queue).to eq message_queue
              end
            end

            context "and message with such serial was present in the message queue" do
              let :message_queue, do: %{2 => {:some_queue_id, 1234}, 3 => {:some_other_id, 4567}}

              it "should call handle_method_return of the module with queue id set to appropriate queue id" do
                described_module.handle_info(message, state)
                expect(TestModule).to accepted(:handle_method_return, [3, "org.freedesktop.DBus", 2, [["org.freedesktop.DBus", ":1.3",
                    "org.radiokit.plumber.backend", ":1.53", ":1.4", ":1.0", ":1.10", ":1.9",
                    ":1.5", ":1.105", ":1.6", ":1.2"]], :some_queue_id, %{}], [pid: self(), count: 1])
              end

              it "should return a new state with message queue that does not contain queue id for received message" do
                {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
                expect(new_message_queue).to eq %{3 => {:some_other_id, 4567}}
              end
            end

            it "should return a {:noreply, new_state}" do
              {retval, _new_state} = described_module.handle_info(message, state)
              expect(retval).to eq :noreply
            end

            it "should return a new state with empty buffer" do
              {:noreply, %{buffer: buffer}} = described_module.handle_info(message, state)
              expect(buffer).to eq << >>
            end

            it "should return a new state with unmodified hello serial" do
              {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
              expect(new_hello_serial).to eq hello_serial
            end
          end

          pending "if message is a error"
        end

        context "if bitstring contains a message with missing data" do
          # Hello with missing 1 byte at the end of header padding
          let :bitstring, do: << 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00 >>

          before do
            allow(TestModule).to accept(:handle_method_call, fn(_, _, _, _, _, _, _, _) -> {:noreply, %{}} end)
          end

          it "should not call handle_method_call of the module" do
            described_module.handle_info(message, state)
            expect(TestModule).not_to accepted(:handle_method_call)
          end

          it "should return a {:noreply, new_state}" do
            {retval, _new_state} = described_module.handle_info(message, state)
            expect(retval).to eq :noreply
          end

          it "should return a new state with buffer containing old buffer plus received data" do
            {:noreply, %{buffer: new_buffer}} = described_module.handle_info(message, state)
            expect(new_buffer).to eq buffer <> bitstring
          end

          it "should return a new state with unmodified message queue" do
            {:noreply, %{message_queue: new_message_queue}} = described_module.handle_info(message, state)
            expect(new_message_queue).to eq message_queue
          end

          it "should return a new state with unmodified hello serial" do
            {:noreply, %{hello_serial: new_hello_serial}} = described_module.handle_info(message, state)
            expect(new_hello_serial).to eq hello_serial
          end
        end
      end
    end
  end
end
