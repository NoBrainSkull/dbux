defmodule DBux.Protocol do
  @type endianness :: :little_endian | :big_endian

  @doc """
  Unmarshalls given bitstring while interpreting data using given endianness
  and signature (where signature comes in D-Bus format).

  It returns `{:ok, {list_of_values, rest}}` on success.

  If `unwrap_values` is `false`, `list_of_values` will contain a nested list of
  `DBux.Value` structs, otherwise it will contain plain values.

  For example, signature "i(ss)" will map to the following result:
  `[%DBux.Value{type: :int32, value: 123},
    %DBux.Value{type: :struct, value: [
      %DBux.Value{type: :string, value: "sample1"},
      %DBux.Value{type: :string, value: "sample2"}]]`

  if unwrap_values is set to `false`, but it will map to:

  `[123, {"sample1", "sample2"}]` if it is set to `true`.

  `rest` will contain remaining part of the bitstring.

  It returns `{:error, reason}` in case of failure.

  Specifically, it returns `{:error, :bitstring_too_short}` if given bitstring
  was not long enough.
  """
  @spec unmarshall_bitstring(Bitstring, endianness, String.t, boolean) :: {:ok, DBux.Value.list_of_values, Bitstring} | {:error, any}
  def unmarshall_bitstring(bitstring, endianness, signature, unwrap_values) when is_binary(bitstring) and is_atom(endianness) and is_binary(signature) do
    case DBux.Type.type_from_signature(signature) do
      {:ok, signature_as_list} ->
        unmarshall_bitstring_step(bitstring, endianness, signature_as_list, unwrap_values, [])

      {:error, reason} ->
        {:error, reason}
    end
  end


  @doc """
  Unmarshalls given bitstring while interpreting data using given endianness
  and signature (where signature comes in as nested list of types, such as
  one generated by `DBux.Type.type_from_signature/1`).

  It returns `{:ok, {list_of_values, rest}}` on success.

  If `unwrap_values` is `false`, `list_of_values` will contain a nested list of
  `DBux.Value` structs, otherwise it will contain plain values.

  For example, signature "i(ss)" will map to the following result:
  `[%DBux.Value{type: :int32, value: 123},
    %DBux.Value{type: :struct, value: [
      %DBux.Value{type: :string, value: "sample1"},
      %DBux.Value{type: :string, value: "sample2"}]]`

  if unwrap_values is set to `false`, but it will map to:

  `[123, {"sample1", "sample2"}]` if it is set to `true`.

  `rest` will contain remaining part of the bitstring.

  It returns `{:error, reason}` in case of failure.

  Specifically, it returns `{:error, :bitstring_too_short}` if given bitstring
  was not long enough.
  """
  @spec unmarshall_bitstring(Bitstring, endianness, DBux.Type.list_of_types, boolean) :: {:ok, DBux.Value.list_of_values, Bitstring} | {:error, any}
  def unmarshall_bitstring(bitstring, endianness, signature, unwrap_values) when is_binary(bitstring) and is_atom(endianness) and is_list(signature) do
    unmarshall_bitstring_step(bitstring, endianness, signature, unwrap_values, [])
  end


  def marshall_bitstring(values, endianness) when is_list(values) and is_atom(endianness) do
    marshall_bitstring_step(values, endianness, << >>, << >>)
  end


  defp marshall_bitstring_step([], _endianness, bitstring_acc, signature_acc) do
    {:ok, {bitstring_acc, signature_acc}}
  end


  defp marshall_bitstring_step([head|tail], endianness, bitstring_acc, signature_acc) do
    case DBux.Value.marshall(head, endianness) do
      {:ok, {value, _padding}} ->
        marshall_bitstring_step(tail, endianness, bitstring_acc <> value, signature_acc <> DBux.Type.signature(head))
    end
  end


  defp unmarshall_bitstring_step(bitstring, _endianness, [], _unwrap_values, acc) do
    {:ok, {acc, bitstring}}
  end


  defp unmarshall_bitstring_step(<< >>, _endianness, [_signature_head|_signature_rest], _unwrap_values, _acc) do
    {:error, :bitstring_too_short}
  end


  defp unmarshall_bitstring_step(bitstring, endianness, [signature_head|signature_rest], unwrap_values, acc) do
    parsed_value = case signature_head do
      {subtype_major, subtype_minor} ->
        DBux.Value.unmarshall(bitstring, endianness, subtype_major, subtype_minor, unwrap_values, 0)

      _ ->
        DBux.Value.unmarshall(bitstring, endianness, signature_head, nil, unwrap_values, 0)
    end

    case parsed_value do
      {:ok, {value, bitstring_rest}} ->
        unmarshall_bitstring_step(bitstring_rest, endianness, signature_rest, unwrap_values, acc ++ [value])

      {:error, reason} ->
        {:error, reason}
    end
  end
end
